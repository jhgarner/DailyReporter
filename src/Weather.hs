{-# LANGUAGE OverloadedStrings #-}

module Weather
  ( weather
  ) where

import Control.Lens
import Data.Aeson
import Data.Aeson.Lens

import Data.Maybe

import Data.Text
import Data.Text.IO

import Data.Time.Clock.POSIX
import Data.Time.Format
import Data.Time.LocalTime
import Text.Read (readMaybe)

import Data.HashMap.Strict

import Utils

import Parser

import Prelude hiding (readFile)

-- |Configuration for weather information (location and apikey)
data WeatherConfig = Config {
    apikey :: String,
    loc :: (String, String)
} deriving (Read, Show)

-- |The final html text generated by weather.
weather :: IO Text
weather = do
  config <- readConfig "WeatherConfig"
  w <- response config
  parser <- readFile "parsers/weather.json"
  h <- htmlS
  return . fromMaybe "Error getting weather" $ do
    -- TODO use lenses here
    params1 <- extractJson parser w
    let params2 = update (Just . getTime) "*tht" params1
    let params = update (Just . getTime) "*tlt" params2
    Just (template (toList params) h)


-- |Templating (uses simple *) for weather email section.
-- (templates/Weather.html)
htmlS :: IO Text
htmlS = Data.Text.IO.readFile "templates/Weather.html"

-- |Grabs the json from the url for darksky api. Uses weather configuration.
response :: WeatherConfig -> IO Text
response config = do
    r <- request config
    getHttp r

-- |Creates url for json request from darksky. Uses weather configuration.
request :: WeatherConfig -> IO String
request config = do
    return $ "https://api.darksky.net/forecast/" ++ api ++ path
    where
        api = apikey config
        location = loc config
        path = "/" ++ fst location ++ "," ++ snd location

-- |Hardcoded TimeZone
currentZone :: TimeZone
currentZone = hoursToTimeZone (-6)

-- |Used to get time from darksky api. Solely for this.
-- TODO make this a little less gross to look at
getTime :: Text -> Text
getTime t = maybe t
    (pack .
    formatTime defaultTimeLocale "%H:%M" .
    utcToZonedTime currentZone .
    posixSecondsToUTCTime .
        realToFrac) $ (readMaybe :: String -> Maybe Double) $ unpack t